const Block = require('./Block.js');
const Transaction = require('./Transaction');






class Blockchain {
	constructor () {
		this.chain = [this.createGenesisBlock()];
		// here we set the difficulty level explained above mineBlock function, dont set it too high because its gonna take long
		this.difficulty = 3;
		this.pendingTransactions = [];
		this.miningReward = 1000;
		this.hey = 0;

		// variables for calculating timestamp parameter
		this.now = new Date();
		this.jsonDate = this.now.toJSON();
	}

	// initializes Blockchain giving info to the 1st block, constructor calls this funcion
	// to initialize the Blockchain
	createGenesisBlock() {
		return new Block(Date.now(), "Genesis Block", "0", null);
	}


	getLatestBlock() {
		return this.chain[this.chain.length - 1];
	}

	minePendingTransactions(mineAddressWinner) {
		// what this function does is creates a new block, pushing the miner address into the blockchain closing that block

		// here we create the new block with the actual date and the pending transactions defining in the following line the mineblock with the difficulty
		// actually in the real world we dont even add the total of pending transactions to the blockchain, in exchange, every user has to chose what transaction he will add
		let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);
		block.mineBlock(this.difficulty);
		
		// when it was already mined it shows on the console
		// when its finished it tooks the variable block and push it to the blockchain creating a new block and closing the last one 
		console.log('Block Succesfully mined!');
		this.chain.push(block);
		

		//console.log(this.chain);
		// in this line we push the winner transactions first on the block after closing it above, chapucero 
		this.pendingTransactions = [
			new Transaction(this.jsonDate, null, mineAddressWinner, this.miningReward, null)

		];
	}

	getBlocks() {
		return this.chain;
	}
	
	addTransaction(transaction) {
		if (!transaction.SSSSdata) {
			console.log('Incomplete SSSS verification');
		} else  {
			console.log('Complete SSSS verfication')
		}


		if (!transaction.fromAddress || !transaction.toAddress) {
			throw new Error('Incomplete addresses');
		}


		if (!transaction.isValid()) {
			throw new Error('Cannot add invalid transaction to the chain');
		}



		// this function pushes the transaction into the pendingTransactions array
		this.pendingTransactions.push(transaction);
	}
	


	returnPendingTransactions() {
		// this function returns the pending Transactions before the block is closed 
		return this.pendingTransactions;
	}



		getAddressBalance(address) {
		let balance = 0;

   		for (const block of this.chain) {
  		    for (const trans of block.transactions) {
   			    if (trans.fromAddress === address) {
          		   	balance -= trans.ammount;
        		}

        		if (trans.toAddress === address) {
          			balance += trans.ammount;
        		}
      		}
    	}
    	if (balance >= 0) {
    		return balance;
    	} else {
    		throw new Error("Negative balance, balance can't be negative!");
    	}
		
	}

	addBlock(newBlock) {
		newBlock.previousHash = this.getLatestBlock().hash;
		//newBlock.hash = newBlock.calculateHash();

		newBlock.mineBlock(this.difficulty);
		this.chain.push(newBlock);

	}

	// now we want a function that verifies every hashs block is correct and that all the blocks are refered to his previous block
	isChainValid() {
		for (let i = 0; i < this.chain.lenght; i++) {
			// counters
			const currentBlock = this.chain[i];
			const previousBlock = this.chain[i - 1];
			
			if (!currentBlock.hasValidTransactions()) {
				return false;
			}


			if (currentBlock.hash !== currentBlock.calculateHash()) {
				return false;

			}
			if (currentBlock.previousHash !== previousBlock.calculateHash()) {
				return false;
			}
		}
		console.log('Valid Chain, hash of blocks correct, previousHashes correct');
		return true;
	}
}


module.exports = Blockchain;