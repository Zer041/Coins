const Block = require('./Block.js');
const Wallet = require('./Wallet.js')

// elliptic-curve
const EC = require('elliptic').ec;
const ec = new EC('secp256k1');


// secrets.js-grempe
const sss = require('secrets.js-grempe');

// crypto-js
const SHA256 = require('crypto-js/sha256');
const SHA3 = require('crypto-js/sha3');
const RIPEMD160 = require('crypto-js/ripemd160');


class Transaction {
	constructor(timestamp, fromAddress, toAddress, ammount, SSSSdata) {
		this.finalCombination = null;
		this.timestamp = timestamp;
		this.fromAddress = fromAddress;
		this.toAddress = toAddress;
		this.ammount = ammount;
		this.SSSSdata = SSSSdata;
	}


	calculateHash() {
		// calculate the hash of the Transaction constructor parameters using RIPEMD160(SHA256()) and returns it
		return RIPEMD160(SHA256(this.timestamp + this.fromAddress + this.toAddress + this.ammount + this.SSSSdata).toString()).toString();
	}


	// in this function we use a key for signing the calculateHash output, so we can sign our transaction
	signTransaction(signingKey) {
		// here we verify if the private key used for signign the public key === the fromAddress, if it doesnt we throw the following error
		if (signingKey.getPublic('hex') !== this.fromAddress) {
			throw new Error('You cannot sign transaction for other Wallets');
		}

		if (!this.SSSSdata || this.SSSSdata.length === 0) {
			console.log('Empty Secrets data: ', this.SSSSdata);
		} else {
			this.finalCombination = this.combineShares();
		}


		const transactionHash = this.calculateHash();
		const signa = signingKey.sign(transactionHash, 'base64');

		this.signature = signa.toDER('hex');
	}


	combineShares() {
		var comb = sss.combine(this.SSSSdata);
		comb = sss.hex2str(comb);
		return comb;
	}

	isValid() {
		// here we have to think about mining reward transactions, it comes from a null fromAddress, so we have to take that
		if (this.fromAddress === null) {
			return true;
		}

		if (this.SSSSdata === null) {
			return true;
		}


		// here we have to check if it has a signature, if it doesnt, we throw an error. We compare if it exists or if its empty
		if (!this.signature || this.signature.length === 0) {
			throw new Error('You dont have a signature for this transaction');
		}


		// here we have to check if the transaction was signed with the correct key
		// in the following line we will extract the public key from the this.fromAddress
		// after following line we use the ec function for validate if the hash of this transaction has been signed with the signature
		const publicKey = ec.keyFromPublic(this.fromAddress, 'hex');
		return publicKey.verify(this.calculateHash(), this.signature);
	}
}


module.exports = Transaction;

